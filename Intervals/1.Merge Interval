/*
ONLY RULE THAT MATTERS
If next.start  ≤  current.end  →  intervals overlap
Else                                they don’t

Input:

[1,3], [2,4], [6,7], [5,6]


Step 1: Sort:

[1,3], [2,4], [5,6], [6,7]


Step 2: Start with [1,3]

Check with [2,4]:

2 ≤ 3 → overlap  
merge → [1,4]


Check with [5,6]:

5 ≤ 4 → NO overlap  
push [1,4]  
current = [5,6]


Check with [6,7]:

6 ≤ 6 → overlap  
merge → [5,7]


Final:

[1,4], [5,7]


 public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals, (a,b)-> a[0] - b[0]);
        List<int[]> result = new ArrayList<>();
        for(int[] interval:intervals){
            if(result.size()==0){
                result.add(interval);
                continue;
            }
            
                int[] last = result.get(result.size() - 1);
            

            if(interval[0]<=last[1]){
                last[1] = Math.max(last[1],interval[1]);
            }else{
                result.add(interval);
            }
        }
        return result.toArray(new int[result.size()][]);
    }


Non - overlapping intervals 
In non overlapping intervals problem the concept always runs behind those intervals which takes time long to finish the meeting i.e sort the intervals on the basis of end time .
and then checks curr.start > last.end


 Arrays.sort(intervals , (a,b) -> a[1] - b[1]);
        int count = 1;
        int lastEnd = intervals[0][1];

        for(int i=1;i<intervals.length;i++){
            if(intervals[i][0] >= lastEnd){
                count++;
                lastEnd = intervals[i][1];
            }
        }
        return intervals.length - count;


        
*/
