/*
ONLY RULE THAT MATTERS
If next.start  ≤  current.end  →  intervals overlap
Else                                they don’t

Input:

[1,3], [2,4], [6,7], [5,6]


Step 1: Sort:

[1,3], [2,4], [5,6], [6,7]


Step 2: Start with [1,3]

Check with [2,4]:

2 ≤ 3 → overlap  
merge → [1,4]


Check with [5,6]:

5 ≤ 4 → NO overlap  
push [1,4]  
current = [5,6]


Check with [6,7]:

6 ≤ 6 → overlap  
merge → [5,7]


Final:

[1,4], [5,7]


 public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals, (a,b)-> a[0] - b[0]);
        List<int[]> result = new ArrayList<>();
        for(int[] interval:intervals){
            if(result.size()==0){
                result.add(interval);
                continue;
            }
            
                int[] last = result.get(result.size() - 1);
            

            if(interval[0]<=last[1]){
                last[1] = Math.max(last[1],interval[1]);
            }else{
                result.add(interval);
            }
        }
        return result.toArray(new int[result.size()][]);
    }


Non - overlapping intervals 
In non overlapping intervals problem the concept always runs behind those intervals which takes time long to finish the meeting i.e sort the intervals on the basis of end time .
and then checks curr.start > last.end


 Arrays.sort(intervals , (a,b) -> a[1] - b[1]);
        int count = 1;
        int lastEnd = intervals[0][1];

        for(int i=1;i<intervals.length;i++){
            if(intervals[i][0] >= lastEnd){
                count++;
                lastEnd = intervals[i][1];
            }
        }
        return intervals.length - count;



INTERVAL LIST INTERSECTIONS
PROBLEM STATEMENT (Simple words)

Tumhare paas 2 lists of sorted intervals hain.

Example:

A =

[1,3], [5,6], [7,9]


B =

[2,3], [5,7]


Find all overlapping regions.

Matlab, jahan dono lists ke intervals common time share karte hain.


List<int[]> result = new ArrayList<>();
int i = 0;
int j = 0;
int n = firstList.length;
int m = secondList.length;
while(i<n && j<m){
    int start = Math.max(firstList[i][0],secondList[j][0]);
    int end = Math.min(firstList[i][1],secondList[j][1]);

    if(start<=end){
        result.add(new int[]{start,end});
    }
    if(firstList[i][1]<=secondList[j][1]){
        i++;
    }else{
        j++;
    }
}

return result.toArray(new int[result.size()][]);
        
*/
