Toh ab hum string related sliding window ke pattern ke question krenge lets start in this text file 


SLIDING WINDOW = BASIC THINKING

Khud se pooch:
1️. Kya question substring ke baare me hai?
2️. Kya longest / smallest / max / min poocha gaya hai?
3️. Kya window ko aage badha ke answer mil sakta hai?

 Haan = Sliding Window

 LONGEST SUBSTRING WITHOUT REPEATING CHARACTERS

 Ab ye problem ka sol jb maine likha toh ye tha 

    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();

        int l = 0;
        int r = 0;
        int maxlen = 0;
        while(r<s.length()){
            char c = s.charAt(r);

            if(set.contains(c)){
                set.remove(s.charAt(l));
                l++;
            }
            set.add(c);
            maxlen = Math.max(maxlen , r - l + 1);
            r++;
        }
        return maxlen;
    }


    but when we apply it isme ek aadha case (testcase ) fail hoga hi hoga toh phir dikkt ye hai ki "if" lagane ki wjh se wo ek baar hi dekh rha hai duplicate but kbhi kbhi wo bahottt baar repeat ho rhe hai toh hume iska dhyan rkhna then ye code hi same "while" lagake run kiya and then done all testcases are passed.

    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();

        int l = 0;
        int r = 0;
        int maxlen = 0;
        while(r<s.length()){
            char c = s.charAt(r);

            while(set.contains(c)){
                set.remove(s.charAt(l));
                l++;
            }
            set.add(c);
            maxlen = Math.max(maxlen , r - l + 1);
            r++;
        }
        return maxlen;
    }

Hmari is sliding window of string ki journey ka agla pdav ya ques hai 
 LONGEST REPEATING CHARACTER REPLACEMENT

 Ek string di hai aur ek number k.
Tum max k characters replace kar sakte ho
taaki window ke andar sab characters same ho jaayein.

s = "AABABBA", k = 1

l = 0
freq = {}
maxFreq = 0
maxLen = 0

r = 0 → 'A'
freq[A] = 1
maxFreq = 1
window = "A"
replacements = 1 - 1 = 0 <= k ✔
maxLen = 1


r = 1 → 'A'
freq[A] = 2
maxFreq = 2
window = "AA"
replacements = 2 - 2 = 0 ✔
maxLen = 2


r = 2 → 'B'
freq[B] = 1
maxFreq = 2
window = "AAB"
replacements = 3 - 2 = 1 <= k ✔
maxLen = 3


r = 3 → 'A'
freq[A] = 3
maxFreq = 3
window = "AABA"
replacements = 4 - 3 = 1 <= k ✔
maxLen = 4


r = 4 → 'B'
freq[B] = 2
window = "AABAB"
replacements = 5 - 3 = 2  (>k)
 Invalid → shrink

Move l:

remove 'A'
freq[A] = 2
l = 1
Now:

window_size = 4
replacements = 4 - 2 = 2 
Shrink again:

remove 'A'
freq[A] = 1
l = 2
Now:

window = "BAB"
window_size = 3
replacements = 3 - 2 = 1 
Continue sliding…

Final:

maxLen = 4


 int[] freq = new int[256];
        int left = 0;
        int right = 0;
        int maxfreq = 0;
        int maxlen = 0;

        while(right<s.length()){
            char c = s.charAt(right);

            freq[c - 'A']++;
            maxfreq = Math.max(maxfreq , freq[c - 'A']);

            while((right - left + 1) - maxfreq > k){
                freq[s.charAt(left) - 'A']--;
                left++;
            }
            maxlen = Math.max(maxlen , right - left + 1);
            right++;
        }
        return maxlen;

now we move on to the next problem to the permutation in string 

Agar s1 length = k
to s2 me har window of size k check karo
ki kya uski frequency s1 ke barabar hai.

    public boolean checkInclusion(String s1, String s2) {
        if(s1.length() > s2.length()) return false;
        
        int[] freq = new int[256];
        int[] freq2 = new int[256];
        for(char c: s1.toCharArray()){
            freq[c - 'a']++;
        }
        int left = 0;
        int right = 0;
        int k = s1.length();

        while(right < s2.length()){
            freq2[s2.charAt(right) - 'a']++;

            if(right - left + 1 > k){
                freq2[s2.charAt(left) - 'a']--;
                left++;
            }

            if(right - left + 1 == k && Arrays.equals(freq,freq2)){
                return true;
            }
            right++;
        }
        return false;
    }

Minimum Window Substring 


    public String minWindow(String s, String t) {
        if(s.length() < t.length()) return "";

        int[] need = new int[128];
        for(char c: t.toCharArray()){
            need[c]++;
        }
       int left = 0;
       int right = 0;
       int minlen = Integer.MAX_VALUE;
       int start = 0;
       int required = t.length();

       while(right<s.length()){
        char c = s.charAt(right);
         
         if(need[c] > 0) required--;
         need[c]--;
         right++;

         while(required==0){
        if(right - left < minlen){
            minlen = right - left;
            start = left;
        }

        char leftchar = s.charAt(left);
        need[leftchar]++;
        if(need[leftchar] > 0) required++;
        left++;
         }
       }
       return minlen == Integer.MAX_VALUE ? "" : s.substring(start, start + minlen);
    }
